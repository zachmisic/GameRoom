DESIGN PARADIGM
We chose component level design as the design paradigm for our project three prototype. The component level design involves splitting the code up into classes and having one main file which runs the whole thing, while the smaller jobs are localized to the independent classes. We like this paradigm of design because of the high cohesion / low coupling effects it has on the program as a whole, it is also a very efficient design layout for debugging because in the gui linux terminal the class and function with the error is always listen in both compilation and the valgrind command in terminal. This made it so we never had to search through a whole 10000 line file and instead just had to find the class. It also made the makefile make sense, because everything just needed to connect to the main. We chose this prototype because it lends itself best to the menu-process type project we intended to build. It also makes itself most available for us, the team members, to each work at different times on the project and not have to depend on each other and wait for someone to finish their part before the others could begin theirs. This was important because an issue in getting our previous projects done on time had been dependency on others and lack of follow through. This paradigm made this project the least issue-causing it could have been, while also allowing us to collaborate with each other as a team efficiently.

SOFTWARE ARCHITECTURE
Based on our design paradigm choice of component level design, the software architecture of our prototype is mostly a 3-tier architecture. The terminal serves as the first tier, acting as the presentation tier for our prototype. The terminal is where the user chooses to run the program and is then presented with the menu to interact with and choose what game they want to play or whether they want to quit the program. The user enters in a value which is read in by the next tier down, the logic tier. The logic tier recognizes which game has been selected, flips a switch in this tier, and passes that information (that of the game and what class needs to be called and the functions that need to be activated) onto the next tier which is the data tier. The logic tier is the one that handles the data and distinguishes it between the other options for entries. It handles the decisions that can be made without delving deeper into methods and functions, and things that did not necessarily have to be written out explicitly. The data tier holds the more complicated code which requires more detailed system processing to produce an output in the presentation tier. It then handles information and produces an output based on what it was given by the logic tier and then hands that data back to the logic tier which then synthesizes the data in a way which it can be presented back to the presentation tier in the form of a game board depending on the selection. This is repeated for each possible for game move.  

DESIGN PATTERNS
Some games used an iterator design pattern, where the game board is replaced with every move on the board. This is done using a continuous while loops and calling the necessary functions through a chain of command design pattern within the loop. This allows the functions to be called and replaced until the game reaches a fixed endpoint that was set in one of the called functions or a function within one of those. This is commonly used for animation games because it is easy to model movement and changes in status of an object in this way. 
Some also used the command behavioral design pattern because it limits the amount of function calls that needs to be made explicitly and places more dependence on only one function. 
The program overall uses a Factory method for creational design, which instantiates the program as a whole and allows for selection between the 5 games. The main class, in control of the whole program, chooses what class to instantiate after the user indicates what game they would like to play, so they begin calling the functions for the game. We indicated that this was an important design pattern in our prototype because each class takes control of its own functionality but it is started off by the main class.
A structural pattern that was used as well was Flyweight to handle the number of objects being created at one time, because there are so many different objects happening at once.


